<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="generator" content="http://www.nongnu.org/elyxer/"/>
<meta name="create-date" content="2016-08-20"/>
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all"/>
<title>Converted document</title>
</head>
<body>
<div id="globalWrapper">
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-1"></a><a class="IndexReference" name="entry-OH-0" href="#index-OH">↓</a>OH-Script 
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-1"></a>Introduction 
</h2>
<div class="Unindented">
OpenHoldem’s <a class="IndexReference" name="entry-scripting-language-0" href="#index-scripting-language">↓</a>scripting language is very similar to the C programming expression syntax. If you already know and understand C programming then you have an advantage in that the OH scripting language should be very familiar. This section is largely based off of Ray Bornert’s original WinHoldem "<a class="IndexReference" name="entry-C-tutorial-0" href="#index-C-tutorial">↓</a>C-tutorial" (<a class="FlexURL" href="http://www.winholdem.net/help/help-c.html">http://www.winholdem.net/help/help-c.html</a>).
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2"></a><a class="IndexReference" name="entry-Syntax-0" href="#index-Syntax">↓</a>Syntax 
</h2>
<div class="Unindented">
The general syntax for OpenHoldem formulas is same as that of the C programming language. However, the formulas are strict <i>r-values</i> (right side of an assignment expression), meaning that there is no assignment operator. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3"></a>Comments
</h2>
<div class="Unindented">
C-syntax means of cource C(++)-comments, too. Comments will improve your code and will make it more easy to read and understand, both for yourself and for other people. Make use of them!
</div>
<div class="Indented">
<div class="listing">
<pre class="listing">// This is a C-style-comment
// till the end of the line.
​
/* 
   and this is a C++-style
   multi-line-comment.
*/
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4"></a>Data Types
</h2>
<div class="Unindented">
OH-Script is a programming language without typing. All values are stored as (double) floating point values on the expression stack, regardless if they are <a class="IndexReference" name="entry-floating-point-0" href="#index-floating-point">↓</a>floating points, <a class="IndexReference" name="entry-integer-0" href="#index-integer">↓</a>integers, <a class="IndexReference" name="entry-booleans-0" href="#index-booleans">↓</a>booleans (<a class="IndexReference" name="entry-logical-0" href="#index-logical">↓</a>logicals) or <a class="IndexReference" name="entry-bit-vector-0" href="#index-bit-vector">↓</a>bit-vectors. For bitwise operations the values are first internally converted to integer values and then the operator is applied. 
</div>
<div class="Indented">
If a value is interpreted as numerical or boolean depends solely on the context. A common beginners mistake is to mix up boolean and numerical values, boolean and numerical operators.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5"></a><a class="IndexReference" name="entry-Rounding-error-0" href="#index-Rounding-error">↓</a>Rounding Errors
</h2>
<div class="Unindented">
One of the main problems with floating-points are the inevitable rounding errors (<a class="FlexURL" href="http://floating-point-gui.de/">http://floating-point-gui.de/</a>).. Rounding errors occur for numerical calculations, but also for conversions of floating-point-numbers from <a class="IndexReference" name="entry-decimal-format-0" href="#index-decimal-format">↓</a>decimal format (OH-script) to the internal <a class="IndexReference" name="entry-binary-0" href="#index-binary">↓</a>binary representation (<a class="FlexURL" href="http://en.wikipedia.org/wiki/Binary_numeral_system">http://en.wikipedia.org/wiki/Binary_numeral_system</a>).
</div>
<div class="Indented">
Rounding errors are especially annoying when you compare two numbers, that should be equal from an exact mathematical point of view but are only nearly in practice.
</div>
<div class="Indented">
To overcome this problem OpenHoldem uses approximative comparision for relational and equality operators (&lt; &lt;= &gt; &gt;= == !=). It will treat two numbers as &ldquo;equal&rdquo;, when they differ by not more than <span class="formula">10<sup><sup> − 6</sup></sup></span>. This applies of course only to OH-script; <a class="IndexReference" name="entry-DLL-0" href="#index-DLL">↓</a>DLL--users have to care about correct rounding themselves!
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6"></a><a class="IndexReference" name="entry-Boolean-0" href="#index-Boolean">↓</a>Boolean Logic
</h2>
<div class="Unindented">
A boolean expression is composed of logical operators (not, and, or, xor) and operands. All boolean operands have only two values - true and false. Each logical operand has a very well defined operation upon the operand(s) in the expression, with a very well defined result. When any numeric value is used in conjunction with a logical operator, any zero values are considered to be false (0) and any non-zero values are considered to be true (1). If the numeric value in question is not zero then it is considered to be true for boolean purposes. Reams of material have been written on boolean logic (<a class="FlexURL" href="http://en.wikipedia.org/wiki/Boolean_logic ">http://en.wikipedia.org/wiki/Boolean_logic </a>). 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7"></a><a class="IndexReference" name="entry-Operators-0" href="#index-Operators">↓</a>Operators 
</h2>
<div class="Unindented">
These operators are listed in order of precedence.
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" style="width: 30%;">
Category
</td>
<td align="left" valign="top" style="width: 40%;">
Operator(s)
</td>
<td align="left" valign="top" style="width: 30%;">
Associativity
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Exponentiation
</td>
<td align="left" valign="top" style="width: 40%;">
** ln (not standard ANSI C)
</td>
<td align="left" valign="top" style="width: 30%;">
Right to Left
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Unary
</td>
<td align="left" valign="top" style="width: 40%;">
! ~ - ‘
</td>
<td align="left" valign="top" style="width: 30%;">
Right to Left
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Multiplicative
</td>
<td align="left" valign="top" style="width: 40%;">
* / % 
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Additive
</td>
<td align="left" valign="top" style="width: 40%;">
+ -
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Bitwise Shift
</td>
<td align="left" valign="top" style="width: 40%;">
&lt;&lt; &gt;&gt;
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Relational
</td>
<td align="left" valign="top" style="width: 40%;">
&lt; &gt; &lt;= &gt;=
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Equality
</td>
<td align="left" valign="top" style="width: 40%;">
== != ~~
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Bitwise
</td>
<td align="left" valign="top" style="width: 40%;">
AND &amp;
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Bitwise 
</td>
<td align="left" valign="top" style="width: 40%;">
XOR ^
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Bitwise
</td>
<td align="left" valign="top" style="width: 40%;">
OR |
</td>
<td align="left" valign="top" style="width: 30%;">
 Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Logical
</td>
<td align="left" valign="top" style="width: 40%;">
AND &amp;&amp;
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Logical
</td>
<td align="left" valign="top" style="width: 40%;">
XOR ^^ (not standard ANSI C)
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Logical
</td>
<td align="left" valign="top" style="width: 40%;">
OR ||
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Conditional 
</td>
<td align="left" valign="top" style="width: 40%;">
?:
</td>
<td align="left" valign="top" style="width: 30%;">
Right to Left 
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 30%;">
Group
</td>
<td align="left" valign="top" style="width: 40%;">
() [] {} (not standard ANSI C)
</td>
<td align="left" valign="top" style="width: 30%;">
Left to Right
</td>

</tr>

</table>

</div>
<ul>
<li>
Exponentiation Power ** (not ANSI-C) a ** b Standard algebraic exponentiation on a and b. a is raised to the power of b. 
</li>
<li>
Natural Log ln (not ANSI-C) ln a Standard algebraic natural log of a a == e ** (ln a) 
</li>
<li>
Natural Log Base e (not ANSI-C) e == 2.71828182845905 
</li>
<li>
Unary A unary operator takes a single operand. 
</li>
<li>
Logical NOT ! False when the operand is true. True when the operand is false. a  !a false true true false 0 1 
</li>
<li>
Bitwise NOT ~ Logical NOT operation on a bit by bit basis.<br/>
<table>
<tr>
<td align="center" valign="top">
expression
</td>
<td align="center" valign="top">
binary result
</td>

</tr>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
11001001011101010110010101111010
</td>

</tr>
<tr>
<td align="center" valign="top">
~a
</td>
<td align="center" valign="top">
00110110100010101001101010000101
</td>

</tr>

</table>
 
</li>
<li>
Negation - A good example is the minus sign when it is used to alter the sign of a value. Example: "a + b / -4" The minus sign in front of the 4 is a unary minus. 
</li>
<li>
Bit Count ‘ (not ANSI-C) Provides a count of the number of bits set in any integer value. Here are 3 examples of the number of bits that are set in some 32-bit integer numbers.<br/>
 <table>
<tr>
<td align="center" valign="top">
a 
</td>
<td align="center" valign="top">
‘a
</td>

</tr>
<tr>
<td align="center" valign="top">
0000000000000000000000000000000
</td>
<td align="center" valign="top">
0
</td>

</tr>
<tr>
<td align="center" valign="top">
0000000000000100000000000000000
</td>
<td align="center" valign="top">
1
</td>

</tr>
<tr>
<td align="center" valign="top">
0000010000000100000000000010000
</td>
<td align="center" valign="top">
3
</td>

</tr>
<tr>
<td align="center" valign="top">
1111111111111111111111111111111
</td>
<td align="center" valign="top">
32
</td>

</tr>

</table>

</li>
<li>
Multiplicative Multiply * a * b Standard algebraic multiplication on a and b. 
</li>
<li>
Divide / a / b Standard algebraic division on a and b. 
</li>
<li>
Modulo % a % b Standard algebraic modulo on a and b. 
</li>
<li>
Percentage % a % b The result will be (a / 100) * b. The percentage operator got introduced with OpenPPL. OpenHoldem will assume that &ldquo;%&rdquo; inside an OH-script function means the modulo-operator and that &ldquo;%&rdquo; inside an OpenPPL-function (with WHEN-conditions) means the percentage-operator.
</li>
<li>
Additive Add + a + b Standard algebraic addition on a and b. 
</li>
<li>
Subtract - a - b Standard algebraic subtraction on a and b. 
</li>
<li>
Bitwise Shift Left &lt;&lt; Slides the entire bit pattern to the left by N bits. Note that the leftmost bits are simply dropped and that the rightmost bits are filled with 0’s. The shift magnitude is used as modulo 32, meaning that any shift N that is specified in excess of 32 bits has a N%32 operation performed prior to the shift.<br/>
 <table>
<tr>
<td align="center" valign="top">
expression
</td>
<td align="center" valign="top">
binary result
</td>

</tr>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
11001001011101010110010101111010
</td>

</tr>
<tr>
<td align="center" valign="top">
a&lt;&lt;1
</td>
<td align="center" valign="top">
10010010111010101100101011110100
</td>

</tr>
<tr>
<td align="center" valign="top">
a&lt;&lt;7
</td>
<td align="center" valign="top">
10111010101100101011110100000000
</td>

</tr>
<tr>
<td align="center" valign="top">
a&lt;&lt;31
</td>
<td align="center" valign="top">
00000000000000000000000000000000
</td>

</tr>
<tr>
<td align="center" valign="top">
a&lt;&lt;32
</td>
<td align="center" valign="top">
11001001011101010110010101111010 
</td>

</tr>

</table>
 
</li>
<li>
Bitwise Shift Right &gt;&gt; Slide the entire bit pattern to the right by N bits. Note that the rightmost bits are dropped and that the leftmost bits are filled with 0’s. The shift magnitude is used as modulo 32, meaning that any shift N that is specified in excess of 32 bits has a N%32 operation performed prior to the shift. expression binary result.<br/>
<table>
<tr>
<td align="center" valign="top">
expression
</td>
<td align="center" valign="top">
binary result
</td>

</tr>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
11001001011101010110010101111010
</td>

</tr>
<tr>
<td align="center" valign="top">
a&gt;&gt;1
</td>
<td align="center" valign="top">
01100100101110101011001010111101
</td>

</tr>
<tr>
<td align="center" valign="top">
a&gt;&gt;7
</td>
<td align="center" valign="top">
00000001100100101110101011001010
</td>

</tr>
<tr>
<td align="center" valign="top">
a&gt;&gt;31
</td>
<td align="center" valign="top">
00000000000000000000000000000001
</td>

</tr>
<tr>
<td align="center" valign="top">
a&gt;&gt;32
</td>
<td align="center" valign="top">
11001001011101010110010101111010 
</td>

</tr>

</table>
 
</li>
<li>
Relational Less Than &lt; a b a &lt; b -1 0 true 0 0 false +1 0 false 
</li>
<li>
Greater Than &gt; a b a &gt; b -1 0 false 0 0 false +1 0 true 
</li>
<li>
Less Than Or Equal &lt;= a b a &lt;= b -1 0 true 0 0 true +1 0 false 
</li>
<li>
Greater Than or Equal &gt;= a b a &gt;= b -1 0 false 0 0 true +1 0 true 
</li>
<li>
Equality Equal == a b a == b -1 0 false 0 0 true +1 0 false 
</li>
<li>
Not Equal != a b a != b -1 0 true 0 0 false +1 0 true 
</li>
<li>
Approximately Equal ~~ this operator rounds both sides to integer numbers before comaring. It is especially to support betsize and stacksize comparisons of converted PPL profiles, as Shanky PPL works with integers only.
</li>
<li>
Bitwise AND &amp; Logical AND operation on a bit by bit basis.<br/>
 <table>
<tr>
<td align="center" valign="top">
expression
</td>
<td align="center" valign="top">
binary
</td>

</tr>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
11001001011101010110010101111010
</td>

</tr>
<tr>
<td align="center" valign="top">
b
</td>
<td align="center" valign="top">
01001010010100101110001010101111
</td>

</tr>
<tr>
<td align="center" valign="top">
a&amp;b
</td>
<td align="center" valign="top">
01001000010100000110000000101010
</td>

</tr>

</table>

</li>
<li>
Bitwise OR | Logical OR operation on a bit by bit basis.<br/>
 <table>
<tr>
<td align="center" valign="top">
expression
</td>
<td align="center" valign="top">
binary
</td>

</tr>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
11001001011101010110010101111010
</td>

</tr>
<tr>
<td align="center" valign="top">
b
</td>
<td align="center" valign="top">
01001010010100101110001010101111
</td>

</tr>
<tr>
<td align="center" valign="top">
a | b
</td>
<td align="center" valign="top">
11001011011101111110011111111111
</td>

</tr>

</table>

</li>
<li>
Bitwise XOR ^ Logical XOR operation on a bit by bit basis.<br/>
<table>
<tr>
<td align="center" valign="top">
expression
</td>
<td align="center" valign="top">
binary
</td>

</tr>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
11001001011101010110010101111010
</td>

</tr>
<tr>
<td align="center" valign="top">
b
</td>
<td align="center" valign="top">
01001010010100101110001010101111
</td>

</tr>
<tr>
<td align="center" valign="top">
a^b
</td>
<td align="center" valign="top">
10000011001001111000011111010101
</td>

</tr>

</table>
 
</li>
<li>
Logical AND &amp;&amp; False when any operand is false. True when both operands are true.<br/>
 <table>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
b
</td>
<td align="center" valign="top">
a &amp;&amp; b
</td>

</tr>
<tr>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
false
</td>

</tr>
<tr>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
false
</td>

</tr>
<tr>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
false
</td>

</tr>
<tr>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
true
</td>

</tr>

</table>

</li>
<li>
Logical XOR ^^ (not ANSI-C) False when operands are boolean equal. True when operands are not boolean equal. Note that "a^^b" is equivalent to "(a!=0)^(b!=0)".<br/>
 <table>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
b
</td>
<td align="center" valign="top">
a ^^ b
</td>

</tr>
<tr>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
false
</td>

</tr>
<tr>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
true
</td>

</tr>
<tr>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
true
</td>

</tr>
<tr>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
false
</td>

</tr>

</table>

</li>
<li>
Logical OR || False when both operands are false. True when any operand is true.<br/>
 <table>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
b
</td>
<td align="center" valign="top">
a || b
</td>

</tr>
<tr>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
false
</td>

</tr>
<tr>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
true
</td>

</tr>
<tr>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
true
</td>

</tr>
<tr>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
true
</td>

</tr>

</table>

</li>
<li>
Conditional ?: Standard algorithmic if then else. "a ? b : c" means "If a then b else c".<br/>
 <table>
<tr>
<td align="center" valign="top">
a
</td>
<td align="center" valign="top">
b
</td>
<td align="center" valign="top">
c
</td>
<td align="center" valign="top">
a ? b : c
</td>

</tr>
<tr>
<td align="center" valign="top">
true
</td>
<td align="center" valign="top">
any
</td>
<td align="center" valign="top">
any
</td>
<td align="center" valign="top">
b
</td>

</tr>
<tr>
<td align="center" valign="top">
false
</td>
<td align="center" valign="top">
any
</td>
<td align="center" valign="top">
any
</td>
<td align="center" valign="top">
c
</td>

</tr>

</table>

</li>
<li>
Grouping Operators ()[]{} Note that [] and {} are not ANSI-C. These grouping operators are used to either visibly separate sections of your code for readability and maintainability purposes, or to affect the precedence of logical operation. Note that unlike WinHoldem’s grouping syntax, there is no limitation on how the various grouping operators can be nested. 
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-8"></a>Numeric Constants Floating point constants
</h2>
<div class="Unindented">
All numeric constants are treated internally as double floating point values in base 2. Floating Point Numeric Constants 123.456 0.987 192837465 .5 17. 5.4321e-76 
</div>
<div class="Indented">
Integer constants There are 4 integer options available as well that allow you to select the base of the constant. The 4 available bases are: 16, 8, 4, 2. Prefixing a numeric constant with a zero followed by a letter (see table below) will specify the numeric base of the constant. 
</div>
<div class="Indented">
Letter Base Name x 16 Hex o 8 Octal (non-standard ANSI C) q 4 Quadal (non-standard ANSI C) b 2 Binary (non-standard ANSI C) 
</div>
<div class="Indented">
Examples: 
</div>
<div class="Indented">
<table>
<tr>
<td align="right" valign="top" style="width: 20%;">
Decimal
</td>
<td align="right" valign="top" style="width: 20%;">
Hex
</td>
<td align="right" valign="top" style="width: 20%;">
Octal
</td>
<td align="right" valign="top" style="width: 20%;">
Quadal
</td>
<td align="right" valign="top" style="width: 20%;">
Binary
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
0
</td>
<td align="right" valign="top" style="width: 20%;">
0x0
</td>
<td align="right" valign="top" style="width: 20%;">
0o0
</td>
<td align="right" valign="top" style="width: 20%;">
0q0
</td>
<td align="right" valign="top" style="width: 20%;">
0b0
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
1
</td>
<td align="right" valign="top" style="width: 20%;">
0x1
</td>
<td align="right" valign="top" style="width: 20%;">
0o1
</td>
<td align="right" valign="top" style="width: 20%;">
0q1
</td>
<td align="right" valign="top" style="width: 20%;">
0b1
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
2
</td>
<td align="right" valign="top" style="width: 20%;">
0x2
</td>
<td align="right" valign="top" style="width: 20%;">
0o2
</td>
<td align="right" valign="top" style="width: 20%;">
0q2
</td>
<td align="right" valign="top" style="width: 20%;">
0b10
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
3
</td>
<td align="right" valign="top" style="width: 20%;">
0x3
</td>
<td align="right" valign="top" style="width: 20%;">
0o3
</td>
<td align="right" valign="top" style="width: 20%;">
0q3
</td>
<td align="right" valign="top" style="width: 20%;">
0b11
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
4
</td>
<td align="right" valign="top" style="width: 20%;">
0x4
</td>
<td align="right" valign="top" style="width: 20%;">
0o4
</td>
<td align="right" valign="top" style="width: 20%;">
0q10
</td>
<td align="right" valign="top" style="width: 20%;">
0b100
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
5
</td>
<td align="right" valign="top" style="width: 20%;">
0x5
</td>
<td align="right" valign="top" style="width: 20%;">
0o5
</td>
<td align="right" valign="top" style="width: 20%;">
0q11
</td>
<td align="right" valign="top" style="width: 20%;">
0b101
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
6
</td>
<td align="right" valign="top" style="width: 20%;">
0x6
</td>
<td align="right" valign="top" style="width: 20%;">
0o6
</td>
<td align="right" valign="top" style="width: 20%;">
0q12
</td>
<td align="right" valign="top" style="width: 20%;">
0b110
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
7
</td>
<td align="right" valign="top" style="width: 20%;">
0x7
</td>
<td align="right" valign="top" style="width: 20%;">
0o7
</td>
<td align="right" valign="top" style="width: 20%;">
0q13
</td>
<td align="right" valign="top" style="width: 20%;">
0b111
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
8
</td>
<td align="right" valign="top" style="width: 20%;">
0x8
</td>
<td align="right" valign="top" style="width: 20%;">
0o10
</td>
<td align="right" valign="top" style="width: 20%;">
0q20
</td>
<td align="right" valign="top" style="width: 20%;">
0b1000
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
9
</td>
<td align="right" valign="top" style="width: 20%;">
0x9
</td>
<td align="right" valign="top" style="width: 20%;">
0o11
</td>
<td align="right" valign="top" style="width: 20%;">
0q21
</td>
<td align="right" valign="top" style="width: 20%;">
0b1001
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
10
</td>
<td align="right" valign="top" style="width: 20%;">
0xA
</td>
<td align="right" valign="top" style="width: 20%;">
0o12
</td>
<td align="right" valign="top" style="width: 20%;">
0q22
</td>
<td align="right" valign="top" style="width: 20%;">
0b1010
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
11
</td>
<td align="right" valign="top" style="width: 20%;">
0xB
</td>
<td align="right" valign="top" style="width: 20%;">
0o13
</td>
<td align="right" valign="top" style="width: 20%;">
0q23
</td>
<td align="right" valign="top" style="width: 20%;">
0b1011
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
12
</td>
<td align="right" valign="top" style="width: 20%;">
0xC
</td>
<td align="right" valign="top" style="width: 20%;">
0o14
</td>
<td align="right" valign="top" style="width: 20%;">
0q30
</td>
<td align="right" valign="top" style="width: 20%;">
0b1100
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
13
</td>
<td align="right" valign="top" style="width: 20%;">
0xD
</td>
<td align="right" valign="top" style="width: 20%;">
0o15
</td>
<td align="right" valign="top" style="width: 20%;">
0q31
</td>
<td align="right" valign="top" style="width: 20%;">
0b1101
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
14
</td>
<td align="right" valign="top" style="width: 20%;">
0xE
</td>
<td align="right" valign="top" style="width: 20%;">
0o16
</td>
<td align="right" valign="top" style="width: 20%;">
0q32
</td>
<td align="right" valign="top" style="width: 20%;">
0b1110
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
15
</td>
<td align="right" valign="top" style="width: 20%;">
0xF
</td>
<td align="right" valign="top" style="width: 20%;">
0o17
</td>
<td align="right" valign="top" style="width: 20%;">
0q33
</td>
<td align="right" valign="top" style="width: 20%;">
0b1111
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
16
</td>
<td align="right" valign="top" style="width: 20%;">
0x10
</td>
<td align="right" valign="top" style="width: 20%;">
0o20
</td>
<td align="right" valign="top" style="width: 20%;">
0q100
</td>
<td align="right" valign="top" style="width: 20%;">
0b10000
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
31
</td>
<td align="right" valign="top" style="width: 20%;">
0x1F
</td>
<td align="right" valign="top" style="width: 20%;">
0o37
</td>
<td align="right" valign="top" style="width: 20%;">
0q133
</td>
<td align="right" valign="top" style="width: 20%;">
0b11111
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
127
</td>
<td align="right" valign="top" style="width: 20%;">
0x7F
</td>
<td align="right" valign="top" style="width: 20%;">
0o177
</td>
<td align="right" valign="top" style="width: 20%;">
0q1333
</td>
<td align="right" valign="top" style="width: 20%;">
0b1111111
</td>

</tr>
<tr>
<td align="right" valign="top" style="width: 20%;">
255
</td>
<td align="right" valign="top" style="width: 20%;">
0xFF
</td>
<td align="right" valign="top" style="width: 20%;">
0o377
</td>
<td align="right" valign="top" style="width: 20%;">
0q3333
</td>
<td align="right" valign="top" style="width: 20%;">
0b11111111
</td>

</tr>

</table>

</div>

</div>
</body>
</html>
