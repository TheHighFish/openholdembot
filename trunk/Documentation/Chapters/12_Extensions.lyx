#LyX 1.6.4 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass amsbook
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Extensions
\begin_inset CommandInset label
LatexCommand label
name "cha:Extensions"

\end_inset


\end_layout

\begin_layout Section
\begin_inset Index
status collapsed

\begin_layout Plain Layout
User DLL
\end_layout

\end_inset

User 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
DLL
\end_layout

\end_inset

DLL
\end_layout

\begin_layout Standard
A User DLL provides the ability to extend the functionality of OpenHoldem.
 More details on User DLLs can be found here: {User DLL} 
\end_layout

\begin_layout Section
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Mouse DLL
\end_layout

\end_inset

Mouse 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
DLL
\end_layout

\end_inset

DLL
\begin_inset CommandInset label
LatexCommand label
name "sec:Mouse-DLL"

\end_inset

 
\end_layout

\begin_layout Standard
The mouse DLL extension provides for a user-specified handling of mouse
 actions.
 The standard, reference mouse.dll that is shipped with OpenHoldem performs
 very un-human-like mouse activities.
 For example, instantly warping the mouse pointer to a location on the button
 and clicking is unlikely to be human behavior.
 A human is more likely to start the mouse moving, accelerate to the target,
 then decelerate as the pointer nears the position of the button.
 Simulating mouse movements that are more human-like may help to avoid detection
 by casions.
 
\end_layout

\begin_layout Standard
The mouse DLL extension is available if you would like to implement custom
 mouse action behavior.
 The source code for the reference mouse.dll implementation can be found
 on Google Code in the source code repository.
\end_layout

\begin_layout Standard
Two methods must be exposed in your mouse.dll in order to interface properly
 with OpenHoldem.
 
\end_layout

\begin_layout Standard
“MouseClick” is called when OpenHoldem wants to click a mouse button on
 a specific location on the screen.
 The prototype for the “MouseClick” method is:
\end_layout

\begin_layout Standard

\noun on
MOUSEDLL_API int MouseClick(const HWND hwnd, const RECT rect, const MouseButton
 button, const int clicks, const HWND restore_focus, const POINT restore_cursor)
;
\end_layout

\begin_layout Standard
“MouseClickDrag” is called when OpenHoldem wants to click a mouse button
 at a specific location on the screen, hold it, drag the cursor to another
 location, and then release it.
 Dragging is from rect.left to rect.right, halfway between rect.top and rect.bottom.
 The prototype for the “MouseClickDrag” method is:
\end_layout

\begin_layout Standard

\noun on
MOUSEDLL_API int MouseClickDrag(const HWND hwnd, const RECT rect, const
 HWND restore_focus, const POINT restore_cursor);
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="80text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hwnd (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the HWND of the window to take the mouse action on
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rect (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the bounding rectangle of the area to take action on – this generally correspond
s to a Table Map Region record rectangle, like those that define button
 click areas; this rectangle is in relative client context 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
button (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the mouse button to be clicked, this is an enum:
\end_layout

\begin_layout Plain Layout

\noun on
enum MouseButton 
\end_layout

\begin_layout Plain Layout

\noun on
{ 
\end_layout

\begin_layout Plain Layout

\noun on
    MouseLeft, 
\end_layout

\begin_layout Plain Layout

\noun on
    MouseMiddle, 
\end_layout

\begin_layout Plain Layout

\noun on
MouseRight 
\end_layout

\begin_layout Plain Layout

\noun on
}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
clicks (in) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the number of clicks of the specified button 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
restore_focus (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the HWND of the window to return focus, active and foreground to, after
 the action has been taken; if this is NULL, no focus resotre is requested
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
restore_cursor (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a POINT to return the cursor to, after the action has been taken; if POINT.x
 and POINT.y are set to -1, then no cursor return is requested 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
returnvalue!!!???
\end_layout

\begin_layout Section
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Keyboard DLL
\end_layout

\end_inset

Keyboard 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
DLL
\end_layout

\end_inset

DLL
\begin_inset CommandInset label
LatexCommand label
name "sec:Keyboard-DLL"

\end_inset


\end_layout

\begin_layout Standard
The keyboard DLL extension provides for a user-specified handling of keyboard
 actions.
 The standard, reference keybaord.dll that is shipped with OpenHoldem performs
 very un-human-like keyboard actions.
 For example, there is no delay between keystrokes.
 When SWAGing, a human is likely to have somewhat random delays between
 keypresses as the SWAG amount is entered into the SWAG box.
 Simulating keyboard actions that are more human-like may help to avoid
 detection by casions.
 
\end_layout

\begin_layout Standard
The keyboard DLL extension is available if you would like to implement custom
 keyboard action behavior.
 The source code for the reference keyboard.dll implementation can be found
 on Google Code in the source code repository.
\end_layout

\begin_layout Standard
Two methods must be exposed in your keyboard.dll in order to interface properly
 with OpenHoldem.
 
\end_layout

\begin_layout Standard
“SendString” is called when OpenHoldem wants to send a string to the poker
 client.
 Generally, this method is expected to click in the specified rectangle
 first, to activate it.
 The prototype for the “SendString” method is:
\end_layout

\begin_layout Standard

\noun on
KEYBOARDDLL_API int SendString(const HWND hwnd, const RECT rect, const CString
 s, const bool use_comma, const HWND restore_focus, const POINT restore_cursor);
\end_layout

\begin_layout Standard
“SendKey” is called when OpenHoldem wants to send a single key to the poker
 client.
 Generally, this method is expected to click in the specified rectangle
 first, to activate it.
 The prototype for the “SendKey” method is:
\end_layout

\begin_layout Standard

\noun on
KEYBOARDDLL_API int SendKey(const HWND hwnd, const RECT rect, UINT vkey,
 const HWND restore_focus, const POINT restore_cursor);
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features>
<column alignment="left" valignment="top" width="20text%">
<column alignment="left" valignment="top" width="80text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hwnd (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 the HWND of the window to take the mouse action on
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rect (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the bounding rectangle of the area to click in to activate – this generally
 corresponds to a Table Map Region record rectangle, like the chat box or
 the SWAG field; this rectangle is in relative client context; if the members
 of the RECT struct are {-1,-1,-1,-1} then do not click in the rectangle
 first 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
s (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the string to be sent to the poker client 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
use_comma (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if true, then use a “comma” instead of a “dot” as the decimal separator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vkey (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the VKEY code of the key to send to the poker client
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
restore_focus (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the HWND of the window to return focus, active and foreground to, after
 the action has been taken; if this is NULL, no focus resotre is requested
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
restore_cursor (in)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a POINT to return the cursor to, after the action has been taken; if POINT.x
 and POINT.y are set to -1, then no cursor return is requested
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Scraper DLL
\end_layout

\end_inset

Scraper Override 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
DLL
\end_layout

\end_inset

DLL
\begin_inset CommandInset label
LatexCommand label
name "sec:Scraper-Override-DLL"

\end_inset


\end_layout

\begin_layout Standard
The scraper override DLL extension provides for a user-specified override
 of the output of the screen scraper engine.
 Sometimes, better game state information can be retrieved from poker client
 controls that are not scrapable by the pixel-driven scraper engine in OpenHolde
m, such as by parsing the chat box.
 Parsing the chat box would require direct memory reading of the poker client,
 or DLL injection.
 The approach for such a chat box parsing is beyond the scope of this document,
 but a good discussion on the topic can be found on CodingTheWheel
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.codingthewheel.com/archives/how-i-built-a-working-online-poker-bot-7
\end_layout

\end_inset


\end_layout

\end_inset

: 
\end_layout

\begin_layout Standard
Immediately after the screen scrape is complete, OpenHoldem will pass a
 pointer to a structure containing the results of the scrape to your override
 DLL.
 This is not a const pointer reference, so any of the members of the struct
 can be changed directly.
 The prototype for the method called by OpenHoldem is quite straightforward:
\end_layout

\begin_layout Standard

\noun on
SCRAPERDLL_API void OverrideScraper(SScraperState *state);
\end_layout

\begin_layout Standard
No casting required.
 The members of the SScraperState struct are as follows:
\end_layout

\begin_layout Standard

\noun on
struct SScraperState 
\end_layout

\begin_layout Standard

\noun on
{ 
\end_layout

\begin_layout Standard

\noun on
    char title[512];
\end_layout

\begin_layout Standard

\noun on
    unsigned int card_common[5]; 
\end_layout

\begin_layout Standard

\noun on
    unsigned int card_player[10][2]; 
\end_layout

\begin_layout Standard

\noun on
    unsigned int card_player_for_display[2]; 
\end_layout

\begin_layout Standard

\noun on
    bool dealer[10]; 
\end_layout

\begin_layout Standard

\noun on
    bool sitting_out[10]; 
\end_layout

\begin_layout Standard

\noun on
    CString seated[10]; 
\end_layout

\begin_layout Standard

\noun on
    CString active[10]; 
\end_layout

\begin_layout Standard

\noun on
CString name[10]; 
\end_layout

\begin_layout Standard

\noun on
    double balance[10]; 
\end_layout

\begin_layout Standard

\noun on
    bool name_good_scrape[10]; 
\end_layout

\begin_layout Standard

\noun on
    bool balance_good_scrape[10]; 
\end_layout

\begin_layout Standard

\noun on
    double bet[10]; double pot[10]; 
\end_layout

\begin_layout Standard

\noun on
    CString button_state[10]; 
\end_layout

\begin_layout Standard

\noun on
    CString i86X_button_state[10]; 
\end_layout

\begin_layout Standard

\noun on
CString i86_button_state; 
\end_layout

\begin_layout Standard

\noun on
    CString button_label[10]; 
\end_layout

\begin_layout Standard

\noun on
    double sblind; 
\end_layout

\begin_layout Standard

\noun on
double bblind; 
\end_layout

\begin_layout Standard

\noun on
    double bbet; 
\end_layout

\begin_layout Standard

\noun on
    double ante; 
\end_layout

\begin_layout Standard

\noun on
    LimitType limit; 
\end_layout

\begin_layout Standard

\noun on
    double handnumber; 
\end_layout

\begin_layout Standard

\noun on
    bool istournament; 
\end_layout

\begin_layout Standard

\noun on
};
\end_layout

\begin_layout Standard
Any of these can be changed like so (which will give you four-of-a-kind
 Aces)
\end_layout

\begin_layout Standard
SCRAPERDLL_API void OverrideScraper(SScraperState *state) 
\end_layout

\begin_layout Standard

\noun on
{ 
\end_layout

\begin_layout Standard

\noun on
state->card_common[0] = StdDeck_MAKE_CARD(StdDeck_Rank_ACE,     StdDeck_Suit_HEA
RTS); 
\end_layout

\begin_layout Standard

\noun on
state->card_common[1] = StdDeck_MAKE_CARD(StdDeck_Rank_ACE, StdDeck_Suit_DIAMOND
S); 
\end_layout

\begin_layout Standard

\noun on
state->card_common[2] = StdDeck_MAKE_CARD(StdDeck_Rank_ACE, StdDeck_Suit_SPADES)
; 
\end_layout

\begin_layout Standard

\noun on
state->card_common[3] = StdDeck_MAKE_CARD(StdDeck_Rank_ACE, StdDeck_Suit_CLUBS);
 
\end_layout

\begin_layout Standard

\noun on
}
\end_layout

\begin_layout Standard
And on return, OpenHoldem will instantly use the changed values instead
 of the scraped values.
\end_layout

\begin_layout Section
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Scraper DLL
\end_layout

\end_inset

Scraper-Pre 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
DLL
\end_layout

\end_inset

DLL
\begin_inset CommandInset label
LatexCommand label
name "sec:Scraper-Pre-DLL"

\end_inset


\end_layout

\begin_layout Standard
The scraper-pre DLL extension was added in OH 2.1.0.
 Some casinos have started displaying unusual information in various regions
 that do not have an obvious way to be handled with the current OH design,
 other than scraper override.
 One casino, for example, displays pots like this "150 + (300)".
 "150" is the amount that is committed to the pot in previous rounds, and
 "+ (300)" is the amount that has been bet by players so far in this round.
 Scraper override is intended to be used with DLL injection or chat box
 parsing techniques, and what is needed here is a way to massage the transform
 engine's output before it gets converted internally into consumable numbers.
\end_layout

\begin_layout Standard
"scraperpre" works just like other user DLL extensions.
 It is different from scraper override, in that the string types that come
 out of the transform engine are passed to the DLL, rather than the final
 resultant types (doubles).
 This makes the interface very straightforward.
 The scraper engine will pass transformed strings to a user-coded DLL, the
 DLL can do whatever massaging is necessary, and then the engine will continue
 with what the DLL passes back for further processing.
 In the above example, the scraperpre DLL could be used to simply strip
 everything off of the scraped pot string after + or (.
 The engine would then get "150" back, which would then be processed into
 the correct double type.
 
\end_layout

\begin_layout Standard
Immediately after transforming each region, OpenHoldem will pass a pointer
 to a structure containing the results of the scrape to your override DLL.
 This is not a const pointer reference, so any of the members of the struct
 can be changed directly.
 The prototype for the method called by OpenHoldem is quite straightforward:
\end_layout

\begin_layout Standard

\noun on
SCRAPER_PREPROCESSOR_DLL_API void ProcessMessage(const char *message, const
 void *param);
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

message
\begin_inset Quotes erd
\end_inset

 parameter will contain the name of the region that was just transformed.
 Using our example above for the strange pot, this could be 
\begin_inset Quotes eld
\end_inset

c0pot0
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

param
\begin_inset Quotes erd
\end_inset

 parameter will contain the actual transformed string, as a pointer to a
 CString type.
 Continuing the example above, this would be 
\begin_inset Quotes eld
\end_inset

150 + (300)
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Handling this strange pot format could be as easy as code like this:
\end_layout

\begin_layout Standard
SCRAPER_PREPROCESSOR_DLL_API void ProcessMessage(const char *message, const
 void *param) { 
\end_layout

\begin_layout Standard
if (message==NULL) return;
\end_layout

\begin_layout Standard
if (strncmp(message, "connect", 7)==0) target_hwnd = (HWND *) param;
\end_layout

\begin_layout Standard
if (strncmp(message, "disconnect", 10)==0) target_hwnd = (HWND *) NULL;
\end_layout

\begin_layout Standard
if (strncmp(message, "c0pot0", 6)==0) 
\end_layout

\begin_layout Standard
{
\end_layout

\begin_layout Standard
CString *s = (CString *) param;
\end_layout

\begin_layout Standard
int index;
\end_layout

\begin_layout Standard
index = s->Find('('); if (index==0) s->Empty(); if (index>0) *s = s->Left(index-
1);
\end_layout

\begin_layout Standard
index = s->Find('+'); if (index==0) s->Empty(); if (index>0) *s = s->Left(index-
1);
\end_layout

\begin_layout Standard
} 
\end_layout

\begin_layout Standard
}
\end_layout

\end_body
\end_document
